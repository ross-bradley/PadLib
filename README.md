# PadLib

## PadLib module

PadLib supports both `sync` and `async` operation, as well as cribs to significantly speed up decryption. Encryption speed-ups are a work in progress at the moment (cribs can't speed up encryption as we're effectively decryption random data).

Cribs reduce the number of network roundtrips that are required by roughly 60-80% (assuming a well-ordered crib), and `async` allows blocks to be decrypted in parallel, so you can see notable reductions in decryption speed. For example, assuming 4 blocks of ciphertext (excluding the IV) you can expect to decrypt the message in ~10% of the time compared to doing it the naive, synchronous way.

## PadLib - async

`from padlib import PadLibAsync`

Recommended for most cases where you're exploiting a padding oracle in a web app/service as it benefits from `asyncio`.

At a minimum PadLib requires a ciphertext and a callback function. The ciphertext must be in byte form - PadLib does no encoding/decoding of payloads. That's the job of the callback function.

The callback function must take two arguments (a ciphertext generated by PadLib, and an instance of `aiohttp.ClientSession`), and return True if the ciphertext decrypted to a value with valid padding, or False otherwise. This is where you handle all the implementation specific things like encoding the ciphertext (base64? ASCII hex?), sending a correctly formatted request, and parsing the response to determine the output from the padding oracle.

## PadLib - sync

Recommended for non-standard cases such as when you're not interacting with a web server, or you just don't want to use `asyncio`.

At a minimum PadLib requires a ciphertext and a callback function. The ciphertext must be in byte form - PadLib does no encoding/decoding of payloads. That's the job of the callback function.

The callback function must take one argument (a ciphertext generated by PadLib), and return True if the ciphertext decrypted to a value with valid padding, or False otherwise. This is where you handle all the implementation specific things like encoding the ciphertext (base64? ASCII hex?), sending a correctly formatted request, and parsing the response to determine the output from the padding oracle.

### Basic Decryption

Instantiate PadLib with a valid ciphertext (as bytes - you'll probably need to decode it from base64 etc.) and a callback function, then call the `decrypt()`method.

### Advanced Decryption

PadLib supports cribs - if you know/assume that the plaintext message is comprised of a specific alphabet, provide this in the `crib` parameter to the constructor. During decryption PadLib will try values that will decrypt to these characters first, speeding up decryption.

There are a number of predefined cribs in the `PadLibBase` module (inherited by both `PadLibAsync` and `PadLibSync`), but of course feel free to create your own!

Note - cribs aren't used until the padding bytes have been recovered (PadLib uses its own FSM for this), so don't put padding bytes in the crib. You only need to worry about the plaintext message content.

The `crib` parameter can be either a string, or a an _instance_ of a class that maintains state and returns a different crib depending on that state. The string case is useful where you just want to limit the search space to speed up the decryption with very little effort. The class case is intended to enable the use of a finite state machine (FSM) to help where the plaintext is highly structured, such as JSON, XML, URL params (e.g. `value1=123&value2=something`). The class should expose the `get_crib` function. A bare-bones implemention is shown below:

```py
# a class for providing finite state machine (FSM) capability for crib generation
# this is the bare minimum functionality
# it must have a function called `get_crib` that takes one input (the last plaintext byte that was decrypted) and returns a crib as a list of ints (0..255)
# you can (and should) maintain state here and update the FSM when the data you're decrypting is heavily structured, e.g. JSON, XML, yaml, URL params etc.

class FSM(object):
    def __init__(self, crib):
        self._crib = [ord(ch) for ch in crib]
        self._state = None

    def get_crib(self, last_plaintext_byte):
        # 1. update the state based on the current state and the byte we just decrypted
        # 2. generate a new crib (list of ints ordered most likely -> least likely)
        #      note - you only need to include the values you care about - padlib will append any missing values to cover all eventualities
        # 3. return it to padlib
        return self._crib    
```

*Basic Encryption*

Instantiate PadLib with a valid ciphertext (as bytes - you'll probably need to decode it from base64 etc.) and a callback function then call the `encrypt(message)`method.

PadLib still needs a ciphertext, but it won't use it during encryption (TODO...)

*Advanced Encryption*

We can't use cribs for encryption as we're effectively decrypting random data - no plaintext bytes are any more likely than any others. However we can benefit from a slight speed up where we have a valid ciphertext and its corresponding plaintext. Where the `known_pt` and `known_ct` arguments are both provided to the `decrypt` method, the intermediate value for the final block can be recovered. The final plaintext block can then be encrypted by simply xor'ing it with the recovered intermediate state. This saves on average (128 x blocksize) requests, which is valuable for short ciphertexts, but less noticable for larger ciphertexts.



## Damned Vulnerable Padding Server

A simple Python3 web server that will listen on http://localhost:8080/ and perform encryption and decryption with a static key

* /encrypt - encrypt a random ASCII payload with a static IV and return the ciphertext only
* /encrypt-with-iv - encrypt a random ASCII payload with a random IV and return the IV + ciphertext
* /decrypt - decrypt ciphertext with a static IV and return the plaintext
* /decrypt-with-iv - decrypt a ciphertext with prepended IV and return the plaintext

Padding errors will cause the server to return HTTP/500. In all other cases, it should return HTTP/200

## Test Harness

Executes some test cases:

* Obtains a ciphertext from the Damned Vulnerable Padding Server
* Decrypts the ciphertext using the padding oracle without a crib
* Decrypts the ciphertext using the padding oracle with a crib
* Encrypts a message using the padding oracle
