# PadLib
A Python3 implementation of CBC-mode padding oracle against PKCS#7

## PadLib module

`from padlib import PadLib`

At a minimum PadLib requires a ciphertext and a callback function. The ciphertext must be in byte form - PadLib does no encoding/decoding of payloads. That's the job of the callback function.

The callback function must take one argument (a ciphertext generated by PadLib), and return True if the ciphertext decrypted to a value with valid padding, or False otherwise. This is where you handle all the implementation specific things like encoding the ciphertext (base64? ASCII hex?), sending a correctly formatted request, and parsing the response to determine the output from the padding oracle.

**Basic Decryption**

Instantiate PadLib with a valid ciphertext (as bytes - you'll probably need to decode it from base64 etc.) and a callback function, then call the `decrypt()`method.

**Advanced Decryption**

PadLib supports cribs - if you know/assume that the plaintext message is comprised of a specific alphabet, provide this in the `crib` parameter to the constructor. During decryption PadLib will try values that will decrypt to these characters first, speeding up decryption.

**Basic Encryption**

Instantiate PadLib with a valid ciphertext (as bytes - you'll probably need to decode it from base64 etc.) and a callback function then call the `encrypt(message)`method.

PadLib still needs a ciphertext, but it won't use it during encryption (TOOD...)

**Advanced Encryption**

We can't use cribs for encryption as we're effectively decrypting random data - no plaintext bytes are any more likely than any others. However we can benefit from a slight speed up where we have a valid ciphertext and its corresponding plaintext.

Where the `known_pt` and `known_ct` arguments are both provided to the `decrypt` method, the intermediate value for the final block can be recovered. The final plaintext block can then be encrypted by simply xor'ing it with the recovered intermediate state. This saves on average (128 x blocksize) requests, which is valuable for short ciphertexts, but less noticable for larger ciphertexts.

## Damned Vulnerable Padding Server

A simple Python3 web server that will listen on http://localhost:8080/ and perform encryption and decryption with a static key

* /encrypt - encrypt a random ASCII payload with a static IV and return the ciphertext only
* /encrypt-with-iv - encrypt a random ASCII payload with a random IV and return the IV + ciphertext
* /decrypt - decrypt ciphertext with a static IV and return the plaintext
* /decrypt-with-iv - decrypt a ciphertext with prepended IV and return the plaintext

Padding errors will cause the server to return HTTP/500. In all other cases, it should return HTTP/200

## Test Harness

Executes some test cases:

* Obtains a ciphertext from the Damned Vulnerable Padding Server
* Decrypts the ciphertext using the padding oracle without a crib
* Decrypts the ciphertext using the padding oracle with a crib
* Encrypts a message using the padding oracle

